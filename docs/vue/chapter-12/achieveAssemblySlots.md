---
prev:
    text: 实现 emit
    link: /vue/chapter-12/achieveAssemblyEmit.md
next:
    text: 实现生命周期
    link: /vue/chapter-12/achieveAssemblyMounted.md
---

朋友们，上节学习了如何实现 emit，这节学习如何实现插槽——slots。

我们知道，插槽其实是预留的占位标识，最终交由用户去填充的一种实现。那如何去设计相应的结构和对应的关联是我们分析的重点。根据插槽实现的目的，我们得知：

1. 子组件设置了占位符
2. 父组件在占位符上设置了具体的实现内容

现在的问题是如何表示子组件的占位符，与父组件的具体的插槽内容，以及它们之间有什么联系。那我们目前知道哪些：

1. 子组件的内容是通过 render 去渲染的，渲染的内容是 vnode
2. 父组件调用了子组件，在调用的该节点上，子组件是放在 type 属性上，标签属性是放在 props 上

根据上述已知信息，我们得出的结论是：

1. 子组件中的插槽占位一定是放在 render 函数里的
2. 父组件在调用子组件时设置的具体的占位内容不是放在 type，也不是放在 props 上的，是放在 children 上的

现在的问题是，如何根据得出的信息设计出父组件和子组件的 vnode 结构。我们知道优秀的结构会减少逻辑的复杂性，我们目前完全可以采取都是数组的形式，但问题是，我们特定的插槽标识是唯一值，都设计成数组结构会增加逻辑负担——循环，所以，不能这样处理。

那除了上述得出的信息，我们还知道哪些信息，即使是推测的：

1. 父组件的插槽内容最终是通过在处理子组件的逻辑时适时触发的

根据上述推测内容得知：

1. 子组件是可以通过某种方式拿到父组件的 children 结果并访问到具体的插槽内容的

而这个结论的前半程我们是能实现的，通过 ```n2.children```，所以，我们的主要问题剩下了一点，即——如何让子组件的插槽标识访问父组件的具体的插槽内容。我们现在得到的所有的 vnode 的设计重点如下：

1. 插槽占位是个标识，具备唯一性
2. 子组件的渲染内容是通过 render 渲染实现的
3. 父组件的具体的插槽内容是放在 children 里的

似乎我们得出了一个结果：子组件在渲染的时候，可以通过某种方式找到父组件对应的具体内容，进而实现最终目标。

那如何实现这个目的呢？结合已知信息我们确认了三点构建 vnode 的重要结论：

1. 插槽的占位标识符要放在 render 里
2. 父组件中的具体的插槽内容要和子组件的标识相对应
3. 父组件中的插槽标识与插槽内容采取 map 结构的 key-value 是个不错的方案

现在剩下的唯一问题就是如何设计子组件中的 render 结构，首先我们确认了几点：

1. 它是个 vnode 数组，方便遍历
2. 它的结构是统一的，方便遍历
3. 在遍历过程中可以根据标识符找到父组件中对应的插槽内容

而虚拟节点的结构是固定如下的：

```js
const vnode = {
    type: '',
    props: {},
    children: '' || {} || []
}
```

结合所有已知信息，得出子组件的渲染函数返回的虚拟节点就是父组件中 children 所指向的一组虚拟节点，所以子组件 render 及返回信息为如下结构：

```js
render() {
    return [
        {
            type: '',
            children: ''
        }
    ]
}
```

既然有了结构，那我们现在欠缺的就是如何把具体的插槽的内容放在对应的虚拟节点的 children 上。那如何去实现？首先父组件的内容我们能拿到了，现在就差的是访问，而访问，我们可以通过代理实现。所以 render 的子节点与对应的插槽关联结构如下：

```js
render() {
    return [
        {
            type: '',
            children: [this['标识']]
        }
    ]
}
```

但是为了统一方便代指插槽，减少实例中可能存在的重命名等，优化如下：

```js
render() {
    return [
        {
            type: '',
            children: [this.slots['标识']]
        }
    ]
}
```

但是最终我们需要把 slots 抛出到 setup 的上下文中，这里不能直接使用 slots，所以优化如下：

```js
render() {
    return [
        {
            type: '',
            children: [this.$slots['标识']]
        }
    ]
}
```

这样再通过代理的重定向，就可以进行关联了。但是这个 type 具体是谁，我们就先以具体固定的标识表示，具体子组件和父组件的 vnode 示例如下：

```js
// 子组件 render
render() {
    return [
        {
            type: 'header',
            children: [this.$slots.header()]
        },
        {
            type: 'footer',
            children: [this.$slots.footer()]
        }
    ]
}

// 父组件 vnode
const vnode = {
    type: MyComponent,
    children: {
        header: () => {
            return { type: 'div', children: '我是一段文本' }
        },
        footer: () => {
            return { type: 'div', children: '我是一段文本' }
        }
    }
}
```

完整逻辑如下：

::: details 详细代码
<<< ../source/v.0.0.16/04.index.js
:::

至这里，我们分析并学习了 slots 实现的全过程，了解了其内部实现的原理，以及为什么对应的 vnode 是这样设计的原因。揭开了 slots 的神秘面纱。