---
prev:
    text: keep-alive
    link: /vue/chapter-14/achieveKeepAlive.md
next:
    text: 实现 parser
    link: /vue/chapter-15/achieveParser.md
---

朋友们，上节我们学习了如何实现 keep-alive，知晓了内部组件的实现方式，初步的完成了渲染器的学习，这节开始我们将进入编译器的世界，了解并学习它的实现原理。

本节的主要内容是介绍编译器和实现词法分析。

目前我们学习到的知识有：响应式实现、渲染器实现，它们都是基于处理好的 vnode 的一种技术实现方式。编译器不同，编译器是为这些实现创造基础准备的，即——生成 vnode。

编译器的实现过程有哪些准备工作：

1. 词法分析
2. 语法分析
3. 语义分析
4. 中间代码生成
5. 优化
6. 目标代码生成

总结起来就是：将源代码按照词法分析、语法分析、语义分析后生成模板ast，然后通过转换生成目标代码。其中词法分析、语法分析、语义分析称为编译前端，中间代码生成、优化、目标代码生成称为编译后端。而根据目标平台的不同，相关的技术储备和规格要求也是不同，最终要实现的目标代码也是不同。而 vue 就是一种面向 JS/JSX 实现的代码，本身涉及的代码领域较小，这种实现语言称为 DSL——特定领域语言。

通过以上介绍，我们了解了实现一门定向语言的过程与相关技术储备的要求，知晓了 vue 实现的背景。在此情况下，那就可以按照规范一步一步的去将 vue 设计的结构中的源码一步步转换为平台需要的目标代码。这其中，又因为是一门定向语言，编译后端的过程和语法规范可以适时简化。

了解了这些，我们说下这几步都是分别干什么的：

1. 词法分析：将源码转换成一组简要的节点数组，每个节点都是一个对象，包裹着对应的信息
2. 语法分析：将词法分析的结果按照一定的规则，转换成需要的树结构，称为模板 ast
3. 语义分析：对树结构进行语义检查，检查如标签名称是否合理、v-else 前是否有 v-if 等，进一步优化模板 ast 结构
4. 将模板 ast 转换成平台需要的 ast，如 JS ast
5. 对 JS ast 进行进一步的优化
5. 生成目标代码

知道了这些，我们准备一段内容模板，如下：

```js
<template>
    <div>
        <h1 id='title'>我是一级标题</h1>
    </div>
</template>
```

经过 vue 的 DSL 转换之后，这段代码就变成了：

```js
function render() {
    return h('div', [
        h('h1', { id: 'title' }, '我是一级标题')
    ])
}
```

这其中，```template``` 包裹的内容就是源代码，而我们的目标代码就是渲染函数。

::: tip 注意
第二步语法分析的时候就已经生成了模板 AST 了，语义分析只是进一步的检查和优化。
:::

那了解了这些，我们就要着手进行模板 AST 生成了，但是 AST 生成规则如何我们还不清楚，介绍如下：

1. AST 树的逻辑根节点为 Root，寓意为结束标记，一切开始的地方，其 children 才为真正的根节点
2. 元素标签的类型为 Element，名称用 tag 属性指向
3. 标签的属性和指令存储在 props 数组中
4. 指令节点的类型为 Directive，拥有 name 属性，指向指令名称
5. 表达式节点类型为 Expression，拥有 content 属性，指向表达式内容

::: tip 注意
AST 也称为抽象语法树。
:::

知晓了这些，我们开始着手进行词法分析。由前面描述得知，词法分析就是将源代码拆解为一段包裹着特定信息的节点数组。那要如何去实现呢？这就要有一套规则，一套解析源代码的规则。而解析的规则早就有了统一，如浏览器平台 HTML 的解析规则。vue 遵循着这一套规则，只是因为是定向 DSL 语言，适当的进行了适合自己的调整。规则如下：

![图片](/img/48.png)

这个图的意思是：

1. 我们以源代码的角标为 0 的位置记录为起始状态
2. 遇到 < 进入标签开始状态
3. 遇到 字母 进入标签名称状态
4. 遇到 > 回到起始状态，并记录标签名称
5. 遇到 文本 进入文本状态
6. 遇到 < 进入标签开始状态，并记录文本内容
7. 遇到 / 进入标签结束状态
8. 遇到 字母 进入结束标签名称状态
9. 遇到 > 回到起始状态，并记录标签名称

以下面源代码为例：

```js
<div>我是一段内容</div>
```

具体步骤如下：

1. 遇到 < 进入标签开始状态
2. 遇到 字母，开始存储
3. 遇到 > 回到起始状态，存储字母为开始标签
4. 遇到 文本，进入文本状态，开始存储
5. 遇到 <，进入标签开始状态，并存贮文本
6. 遇到 /，进入标签结束标记
7. 遇到 字母，开始存储
8. 遇到 >，回到其实状态，并记录结束标签

最终生成的一段节点组就是：

- 开始标签 div
- 文本内容 我是一段内容
- 结束标签 div

这样的每一个节点称为 Token，意为词法记号，一组这样的节点称为 Tokens。实现如下：

::: details 详细代码
<<< ../source/v.0.0.19/index.js
:::

最终会得到如下结果：

![图片](/img/47.png)

由结果可知，我们已经实现了如何根据源代码进行词法分析，并得到一组词法记号的功能。

至这里，我们已经完成了对词法分析的实现，知晓了其内部的实现原理——在不同的符号判断处，根据当前的状态，返回不同的词法记号，也知晓了编译器对源代码的处理过程。除此之外，知晓了何为 AST，以及其逻辑根节点和真正的子节点，与具体的规则标记等。明白了编译前端和编译后端的作用，编译前端就是对源代码进行分析，变为模板 AST；编译后端就是将模板 AST 变为目标代码。通过这些学习，我们初步的认识了编译器。下节我们将学习如何在此基础上实现一个模板 AST。